<html>
<head>
  <title>第十章 控制启动过程</title>
  <basefont face="Consolas" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308816 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Consolas;
      font-size: 11pt;
    }
  </style>
</head>
<body>
<a name="9242"/>

<div>
<span><div><div><div><div><div><span style="font-size: 12pt; color: rgb(0, 0, 255); font-weight: bold;">第十章 控制启动过程</span></div><div><br/></div><div><span style="font-weight: bold;">目标：</span></div><ul><li><div>管理启动过程，以控制所提供的服务并对问题进行故障排除和修复。</div></li></ul><div><br/></div></div><div><span style="font-weight: bold;">章节：</span></div><ul><li><div>选择启动目标</div></li><li><div>重置root密码</div></li><li><div>修复在启动时出现的文件系统问题</div></li></ul><div><br/></div><div><br/></div><div><span style="font-weight: bold;">第一节：选择启动目标</span></div><div><span style="font-weight: bold;">目标：</span></div><ul><li><div>完成本节后，学生应该能：</div></li><li><div>  说明RHEL启动过程。</div></li><li><div>  设置启动时使用的默认目标。</div></li><li><div>  将系统启动到非默认目标。</div></li></ul><div><br/></div><div><span style="font-weight: bold;">RHEL 8的启动过程：BIOS固件引导为例</span></div><ul><li><div>计算机通电（加电启动）</div></li><li><div>系统固件（UEFI或BIOS）开机自检（POST），并初始化部分硬件。</div></li></ul><div><br/></div><ul><li><div>系统固件搜索可启动设备，可能在UEFI启动固件中配置，也可能在BIOS中配置的磁盘主启动</div></li></ul><div>     记录（MBR）。</div><ul><li><div>系统固件从磁盘读取 <span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">boot loader</span>（启动加载器），然后将系统控制权交给boot loader。</div></li><li><div>RHEL 8中，boot loader为 GRand Unified Bootloader version 2（<span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">GRUB2</span>）。</div></li><li><div><span style="font-weight: bold;">使用 grub2-install 命令进行配置，它将安装GRUB2作为磁盘上的boot loader。</span></div></li></ul><div>     <span style="color: rgb(0, 0, 255); font-weight: bold;">* 注意：</span>SLES中支持ELILO boot loader（该boot loader不及GRUB2流行）</div><div>       <img src="chapter10_files/Image.png" type="image/png" data-filename="Image.png" width="483"/></div><div><br/></div><ul><li><div>GRUB2基于/boot/grub2/grub.cfg文件显示菜单，从中选择要启动的内核。</div></li></ul><div>     <span style="color: rgb(0, 0, 255); font-weight: bold;">* 注意：</span></div><div>       1. <span style="font-weight: bold;">grub2-mkconfig 命令使用 </span><span style="font-weight: bold;">/etc/grub.d/</span><span style="font-weight: bold;"> 目录、</span><span style="font-weight: bold;">/etc/default/grub</span><span style="font-weight: bold;"> 文件进行配置，</span></div><div><span style="font-weight: bold;">          生成 </span><span style="font-weight: bold;">/boot/grub2/grub.cfg</span><span style="font-weight: bold;"> 文件。</span></div><div>       2. UEFI固件使用GRUB2时，GRUB2配置文件位于 /boot/efi/EFI/redhat/ 目录中。</div><div>       <img src="chapter10_files/Image [1].png" type="image/png" data-filename="Image.png" width="562"/> </div><div><br/></div><ul><li><div>选择内核或超时到期后，boot loader会从磁盘中加载 <span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">kernel</span> 和 <span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">initramfs</span>，放入内存中。</div></li></ul><div>     <span style="color: rgb(0, 0, 255); font-weight: bold;">* 注意：</span></div><div>       1. initramfs是一个存档（archive），其中包含启动时所有必要硬件的内核模块（驱动）、</div><div>          初始化脚本等等。</div><div>       2. 在RHEL 8中，initramfs包含自身可用的整个系统。</div><div>       3. <span style="font-weight: bold;">使用 /etc/dracut.conf.d/ 目录、dracut 命令和 lsinitrd 命令进行配置，以检查</span></div><div><span style="font-weight: bold;">          initramfs文件。</span></div><div><br/></div><ul><li><div>boot loader将控制权交给kernel，传递boot loader的内核选项，及initramfs内核会初始化</div></li></ul><div>     initramfs中含有驱动的所有硬件，initramfs中的 /sbin/init 以 PID 1 启动。</div><ul><li><div><span style="font-weight: bold;">在RHEL 8中，/sbin/init是一个指向systemd的软链接。</span></div></li></ul><div>     <img src="chapter10_files/Image [2].png" type="image/png" data-filename="Image.png" width="578"/></div><ul><li><div>使用内核 init= 命令行参数进行配置。</div></li></ul><div><br/></div><ul><li><div><span style="font-weight: bold;">initramfs中的systemd会执行 initrd.target 中所有单元（unit）。</span></div></li><li><div>这包括将磁盘上的根文件系统挂载到/sysroot目录。</div></li><li><div>使用/etc/fstab进行配置。</div></li></ul><div><br/></div><ul><li><div><span style="color: rgb(158, 0, 243); font-weight: bold;">kernel 将根文件系统从initramfs切换（回转）到/sysroot的根文件系统。</span></div></li><li><div>随后，systemd使用磁盘中的systemd来自行重新执行。</div></li></ul><div><br/></div><ul><li><div><span style="font-weight: bold;">systemd会查找系统默认目标，然后启动（或停止）单元。</span></div></li><li><div>以符合该目标的配置，从而自动解决单元间的依赖关系。</div></li><li><div><span style="font-weight: bold;">本质上，systemd目标是一组系统应激活以达到所需状态的单元。</span></div></li><li><div>这些目标通常启动一个基于文本的登录或图形登录屏幕。</div></li><li><div>使用 /etc/systemd/system/default.target 和 /etc/systemd/system/ 进行配置。</div></li></ul><div><br/></div><div>   <span style="color: rgb(0, 0, 255); font-weight: bold;">* 注意：</span></div><div>     1. RHEL 7/8系统启动过程示意（BIOS固件）：</div><div>     <img src="chapter10_files/RHEL 7或8开机启动流程.png" type="image/png" data-filename="RHEL 7或8开机启动流程.png" width="276"/>      </div><div><br/></div><div>     2. RHEL 5/6系统启动过程示意（BIOS固件）：</div><div>     <img src="chapter10_files/RHEL 5或6开机启动流程.jpg" type="image/jpeg" data-filename="RHEL 5或6开机启动流程.jpg" width="497"/></div><div><br/></div><div>     3. 常见引导方式与磁盘分区类型：</div><div>        a. BIOS固件使用GRUB2引导：系统磁盘使用MBR分区，数据磁盘使用MBR或GPT分区均可。</div><div>        b. UEFI固件使用GRUB2引导：系统磁盘使用GPT分区，数据磁盘使用MBR或GPT分区均可。</div><div><br/></div><div>     4. 常见物理服务器系统启动示例：<span style="font-weight: bold;">HPE DL560 Gen10</span></div><div>     <img src="chapter10_files/HPE Gen10 BIOS启动信息.jpg" type="image/jpeg" data-filename="HPE Gen10 BIOS启动信息.jpg" width="443"/></div><div>     <img src="chapter10_files/HPE Gen10 PCIe扩展卡信息.jpg" type="image/jpeg" data-filename="HPE Gen10 PCIe扩展卡信息.jpg" width="442"/></div><div>     <img src="chapter10_files/HPE Gen10关闭内置SD卡 否则系统将安装至内置SD卡.jpg" type="image/jpeg" data-filename="HPE Gen10关闭内置SD卡 否则系统将安装至内置SD卡.jpg" width="443"/>   </div><div>     <img src="chapter10_files/HPE Gen10 RAID磁盘阵列信息（1）.jpg" type="image/jpeg" data-filename="HPE Gen10 RAID磁盘阵列信息（1）.jpg" width="442"/></div><div><br/></div><div><span style="font-weight: bold;">系统重启和关机：</span></div><ul><li><div>$ systemctl poweroff</div></li></ul><div>     # 停止所有运行的服务，卸载所有文件系统（或在文件系统无法卸载时以只读形式重新挂载），</div><div>       然后关闭系统。</div><div><br/></div><ul><li><div><span style="font-weight: bold;">$ systemctl reboot</span></div></li></ul><div>     # 停止所有运行的服务，卸载所有文件系统，然后重新启动系统。</div><ul><li><div><span style="font-weight: bold;">也可以使用poweroff和reboot，它们是systemctl软链接。</span></div></li></ul><div><br/></div><div><span style="font-weight: bold;">选择systemd目标：</span></div><ul><li><div>systemd目标是一组系统应启动以达到所需状态的systemd单元。</div></li></ul><div>     <img src="chapter10_files/Image [3].png" type="image/png" data-filename="Image.png" width="444"/></div></div><div><br/></div><ul><li><div>某个目标可能属于另一目标，如，graphical.target 包含 multi-user.target，后者反过来</div></li></ul><div>     取决于 basic.target 和其他目标。</div><div><br/></div><ul><li><div><span style="font-weight: bold;">$ systemctl list-dependencies graphical.target | grep target</span></div></li></ul><div>     # 查看graphical.target的依赖目标（正向依赖）</div><div>     <img src="chapter10_files/Image [4].png" type="image/png" data-filename="Image.png" width="577"/></div><div><br/></div><ul><li><div><span style="font-weight: bold;">$ systemctl list-unit --type=target --all</span></div></li></ul><div>     # 查看系统中所有的目标（active与inactive）</div><div>     <img src="chapter10_files/Image [5].png" type="image/png" data-filename="Image.png" width="578"/></div><div><br/></div><div><span style="font-weight: bold;">在运行时切换目标：</span></div><ul><li><div>在运行的系统中，管理员可以使用 systemctl isolate 命令来切换到其他目标。</div></li><li><div><span style="font-weight: bold;">$ systemctl isolate &lt;</span><span style="font-style: italic; font-weight: bold;">target_name</span><span style="font-weight: bold;">&gt;.target</span></div></li></ul><div>     <img src="chapter10_files/Image [6].png" type="image/png" data-filename="Image.png" width="497"/></div><div><br/></div><ul><li><div>隔离某个目标会停止该目标（及其依赖项）不需要的所有服务，并启动任何尚未启动的所需服务。</div></li><li><div>并非所有目标都能隔离。</div></li><li><div>只能隔离单元文件中设置 <span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">AllowIsolate=yes</span> 的目标。</div></li><li><div>如，可以隔离 graphical.target，但不能隔离 cryptsetup.target。</div></li></ul><div>     <img src="chapter10_files/Image [7].png" type="image/png" data-filename="Image.png" width="577"/></div><div>     <img src="chapter10_files/Image [8].png" type="image/png" data-filename="Image.png" width="578"/>    </div><div><br/></div><div><span style="font-weight: bold;">设置默认目标：</span></div><ul><li><div>系统启动时，systemd会激活 <span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">default.target</span> 目标。</div></li><li><div>通常，/etc/systemd/system/ 中的默认目标是指向 graphical.target 或 multi-user.target </div></li></ul><div>     的符号链接。</div><div><br/></div><ul><li><div><span style="font-weight: bold;">$ systemctl get-default</span></div></li></ul><div>     # 查看系统默认目标</div><ul><li><div><span style="font-weight: bold;">$ systemctl set-default multi-user.target</span></div></li></ul><div><span style="font-weight: bold;">     $ systemctl set-default graphical.target</span> </div><div>     # 设置系统默认目标</div><div>     <img src="chapter10_files/Image [9].png" type="image/png" data-filename="Image.png" width="577"/></div><div><br/></div><div><span style="font-weight: bold;">在启动时选择其他目标：</span></div><ul><li><div>如下所示：</div></li></ul><div>     <img src="chapter10_files/1.JPG" type="image/jpeg" data-filename="1.JPG" width="497"/></div><div>     <img src="chapter10_files/2.JPG" type="image/jpeg" data-filename="2.JPG" width="498"/></div><div>     <img src="chapter10_files/3.JPG" type="image/jpeg" data-filename="3.JPG" width="498"/></div><div><br/></div><div>   <span style="color: rgb(0, 0, 255); font-weight: bold;">* 注意： </span></div><div>     1. <span style="font-weight: bold;">$ man 7 bootup</span>：查看系统引导启动的详细过程</div><div>     2. <span style="font-weight: bold;">$ man 7 dracut.bootup</span>：查看initramfs中的引导过程 </div><div><br/></div><div>     <span style="color: rgb(250, 122, 0); font-weight: bold;">练习 P281：</span><span style="color: rgb(250, 122, 0); font-weight: bold;">SELECTING THE BOOT TARGET</span></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">第二节：重置root密码</span></div><div><span style="font-weight: bold;">目标：</span></div><ul><li><div>完成本节后，学生应该能在当前root密码丢失的情况下登录系统并更改root密码。</div></li></ul><div><br/></div><div><span style="font-weight: bold;">从boot loader重置root密码：</span></div><ul><li><div>在RHEL 6及更早的版本中，管理员可以将系统启动到 runlevel 1 以获得root提示符。</div></li><li><div>在RHEL 8计算机上与 runlevel 1 最接近的模拟是 emergency.target 和 rescue.target，</div></li></ul><div>     都需要root密码才能登录。</div><ul><li><div>在RHEL 8中，可使initramfs运行的脚本在某些点暂停，进入root shell，用以重置丢失的</div></li></ul><div>     root密码。</div><div><br/></div><ul><li><div>要访问该root shell，如下所示：</div></li></ul><div>     1. 重新启动系统</div><div>     2. 按任意键（Enter除外）中断boot loader倒计时</div><div>     3. 将光标移至要启动的内核条目</div><div>     4. 按 <span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">e</span> 编辑选定的条目</div><div>     5. 将光标移到内核命令行（以 linux 开头的行）</div><div>     6. 输入 <span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">rd.break</span>（root directory），利用该选项，系统从initramfs向实际系统移交</div><div>        控制权前，系统将会中断。</div><div>     7. 按 <span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">Ctrl+x</span> 进行启动</div><div>     8. <span style="font-weight: bold;">此时，系统会显示root shell，磁盘上的实际根文件系统会只读（ro）挂载到/sysroot，</span></div><div><span style="font-weight: bold;">        需要将根文件系统更改为读/写（rw）。</span></div><div><br/></div><div>        <span style="color: rgb(0, 0, 255); font-weight: bold;">* </span><span style="color: rgb(0, 0, 255); font-weight: bold;">注意：</span></div><div>          1. 此时系统尚未启用SELinux，所创建的任何文件都没有SELinux上下文。</div><div>          2. <span style="font-weight: bold;">确保所有未标记的文件（包括此时的/etc/shadow）在启动过程中都会重新获得标记。</span></div><div>          3. 键入 exit 两次，第一个命令将退出chroot位置（实际的系统根文件系统/sysroot），</div><div>             第二个命令将退出initramfs调试shell。</div><div>          4. 此时，系统将继续进行启动，执行完整的SELinux重新标记，然后再次重新启动。 </div><div>          <img src="chapter10_files/Image [10].png" type="image/png" data-filename="Image.png" width="539"/></div><div><br/></div><div><span style="font-weight: bold;">检查日志：</span></div><ul><li><div>如果system journal在重启后持久保留，则可以使用journalctl工具来检查启动失败日志。</div></li><li><div>默认情况下，系统日志保存在 /run/log/journal 目录中，重启后将被删除。</div></li><li><div><span style="font-weight: bold;">要将日志存储在</span> <span style="font-weight: bold;">/var/log/journal</span> <span style="font-weight: bold;">目录中，可在 /etc/systemd/journald.conf 中将</span></div></li></ul><div><span style="font-weight: bold;">     Storage 参数设置为 persistent。</span></div><div>     <img src="chapter10_files/Image [11].png" type="image/png" data-filename="Image.png" width="578"/></div><div><br/></div><ul><li><div>要检查上一次启动的日志，journalctl使用 -b 选项。</div></li><li><div>如果不使用任何参数，-b 选项将仅显示从上一次启动以来的消息。</div></li><li><div>如果参数为负数，则显示以前的启动的日志。</div></li></ul><div>     <span style="font-weight: bold;">$ journalctl -b &lt;</span><span style="font-style: italic; font-weight: bold;">id</span><span style="font-weight: bold;">&gt; -p &lt;</span><span style="font-style: italic; font-weight: bold;">priority</span><span style="font-weight: bold;">&gt;</span>：查看指定重启过程中相应等级的日志信息</div></div><div>     <img src="chapter10_files/Image [12].png" type="image/png" data-filename="Image.png" width="578"/></div><div>     </div><div><span style="font-weight: bold;">修复systemd启动问题：</span></div><ul><li><div>启用早期调试Shell：</div></li></ul><div>     1. 通过为 <span style="font-weight: bold;">systemctl enable debug-shell.service</span> 启用 debug-shell 服务，系统会于</div><div>        启动序列早期在 TTY9（Ctrl + Alt + F9）上生成一个 root shell。</div><div>     2. 该shell会自动作为 root 登录，管理员可以在操作系统仍在启动时对系统进行调试。</div><div><span style="font-weight: bold;">     </span><span style="color: rgb(0, 0, 255); font-weight: bold;">* 注意：</span></div><div><span style="font-weight: bold;">       </span>1. 在完成调试后，需要禁用 debug-shell.service 服务。</div><div>       2. <span style="font-weight: bold;">该服务会使未经身份验证的 root shell 向任何拥有本地控制台访问权限的人员开放。</span></div><div><br/></div><ul><li><div>使用紧急情况和救援目标：</div></li></ul><div><span style="font-weight: bold;">   </span>  1.<span style="font-weight: bold;"> 通过从boot loader将 systemd.unit=rescue.target 或 systemd.unit=emergency.target</span></div><div><span style="font-weight: bold;">        附加到内核命令行（传递内核参数），系统将生成救援或紧急情况shell，而不是正常启动。</span></div><div>     2. 这两个shell都需要提供 root 密码。</div><div>     3. 紧急情况目标使 root 文件系统以只读（ro）挂载，而救援目标会等待 sysinit.target 完成，</div><div>        这样系统的更多部分会进行初始化，如日志记录服务或文件系统。</div><div><span style="font-weight: bold;">   </span>  4. 此时root用户无法更改 /etc/fstab，直至驱动器以读写状态重新挂载（mount -o remount,rw /）</div><div>        管理员可以使用这些shell来修复妨碍系统正常启动的任何问题。</div><div>     5. 如，服务之间的依赖关系循环，或 /etc/fstab 中的错误条目。</div><div>     6. 从这些shell退出后，系统会继续进行常规启动过程。</div><div><br/></div><div>   <span style="color: rgb(0, 0, 255); font-weight: bold;">* 注意：</span>进入系统启动root shell的场景</div><div>     1. 破解root密码：boot loader内核参数添加 rd.bread</div><div>     2. 进入紧急模式：boot loader内核参数添加 systemd.unit=emergency.target</div><div>     3. 进入救援模式：boot loader内核参数添加 systemd.unit=rescure.target</div><div><br/></div><div><span style="font-weight: bold;">识别阻塞作业：stuck jobs</span></div><ul><li><div>在启动过程中，systemd会生成大量作业。</div></li><li><div>如果其中某些作业无法完成，则它们会妨碍其他作业运行。</div></li></ul><div><br/></div><ul><li><div><span style="font-weight: bold;">$ systemctl list-jobs</span></div></li></ul><div>     # 检查当前作业列表</div><ul><li><div><span style="font-weight: bold;">所有列为 running 的作业都必须先完成，然后列为 waiting 的作业才可以继续。</span></div></li></ul><div><br/></div><div>   <span style="color: rgb(0, 0, 255); font-weight: bold;">* 注意：</span></div><div>     <b>$ man 7 kernel-command-line</b>：查看内核命令行参数<br/></div><div>     <span style="font-weight: bold;">$ man 7 dracut.cmdline</span>：查看dracut kernel命令行选项</div><div>     <img src="chapter10_files/Image [13].png" type="image/png" data-filename="Image.png" width="578"/></div><div><br/></div><div>     <span style="color: rgb(250, 122, 0); font-weight: bold;">练习 P288：</span><span style="color: rgb(250, 122, 0); font-weight: bold;">RESETTING THE ROOT PASSWORD</span></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">第三节：修复在启动时出现的文件系统问题</span></div><div><span style="font-weight: bold;">目标：</span></div><ul><li><div>完成本节后，学生应该能手动修复让启动过程停止的文件系统配置或损坏问题。</div></li></ul><div><br/></div><div><span style="font-weight: bold;">诊断和修复文件系统问题：</span></div><ul><li><div>/etc/fstab中的错误和损坏的文件系统可能会阻止系统启动。</div></li><li><div>大多数情况下，systemd会降至需要提供root密码的紧急修复shell。</div></li></ul><div><br/></div><ul><li><div>常见的文件系统问题：</div></li></ul><div>     <img src="chapter10_files/Image [14].png" type="image/png" data-filename="Image.png" width="499"/></div><div><br/></div><ul><li><div><b>在所有情况下，管理员还都可以使用 emergency.target 来诊断和修复问题，因为在显示</b></div></li></ul><div><b><span>     </span>紧急shell之前，不会挂载任何文件系统。</b></div><div><b><span><br/></span></b></div><div><b>     <font style="color: rgb(0, 0, 255);">* 注意：</font><br/></b></div><div>       1. 适应紧急shell解决文件系统问题时，别忘了在编辑 /etc/fstab 之后运行</div><div><span>    </span><span>      </span><b>systemctl daemon-reload</b>。</div><div><span>    </span><span>   2. </span>如果不重新加载，systemd可能会继续使用旧版本/etc/fstab。 </div><div><br/></div><div><b><font color="#FA7A00"><span>     练习 P292：</span>REPAIRING FILE SYSTEM ISSUES AT BOOT</font></b></div><div><b><font color="#FA7A00"><span>     Lab P295：</span>CONTROLLING THE BOOT PROCESS<br/></font></b></div><div><span style="color: rgb(250, 122, 0);"><b><br/></b></span></div></div><div><br/></div><div><br/></div></span>
</div></body></html> 