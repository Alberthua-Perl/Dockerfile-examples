<html>
<head>
  <title>容器运行时runtime演进与架构概述</title>
  <basefont face="Consolas" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/308816 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: Consolas;
      font-size: 11pt;
    }
  </style>
</head>
<body>
<a name="2184"/>

<div>
<span><div><div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);"><b>容器运行时runtime演进与架构概述</b></span></div><div><span style="font-size: 14pt; color: rgb(45, 79, 201);"><b><br/></b></span></div><div><span style="font-weight: bold;">文档说明：</span></div><ul><li><div>该文档未说明<span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">Kata Container</span>、<span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">gVisor</span>等强隔离的容器runtime。</div></li></ul><div><br/></div><div><span style="font-weight: bold;">Docker架构的技术演进：</span></div><ul><li><div>Docker项目早先已由Docker公司贡献于社区成立Moby项目（Docker CE）。</div></li><li><div>从Docker 1.11版本开始至Docker 17.x版本（或更高版本）逐步将Docker Daemon解耦成</div></li></ul><div>     docker与containerd两个独立的项目，拆分docker的功能。</div><ul><li><div>以下以Docker 1.13.x与Docker 17.x版本（或更高版本）为例说明各组件关系。</div></li></ul><div><br/></div><ul><li><div>Docker 1.13.x组件关系示意：</div></li></ul><div>     docker、dockerd、docker-containerd、docker-containerd-shim、docker-runc</div><div>     <img src="container_runtime_files/2.jpg" type="image/jpeg" data-filename="2.jpg" width="498"/></div><div><br/></div><ul><li><div>Docker 17.x（或更高版本）组件关系示意：</div></li></ul><div>     1. docker、dockerd、containerd、containerd-shim、runc</div><div>     2. dockerd守护进程与containerd实现解耦拆分</div><div>     3. <span style="font-weight: bold;">在低层次上（low-level）containerd可实现与dockerd类似的功能，如容器的创建、</span></div><div><span style="font-weight: bold;">        运行与销毁，容器镜像的拉取与推送等。</span></div><div>        <img src="container_runtime_files/1.png" type="image/png" data-filename="1.png" width="476"/></div><div>        <img src="container_runtime_files/4.png" type="image/png" data-filename="4.png" width="475"/></div><div><br/></div><ul><li><div>Docker 18.09.0与19.03.13进程关系示意：</div></li></ul><div>     <img src="container_runtime_files/Docker 18.x组件关系.JPG" type="image/jpeg" data-filename="Docker 18.x组件关系.JPG" width="497"/></div><div>     <img src="container_runtime_files/1[1].jpg" type="image/jpeg" data-filename="1[1].jpg" width="497"/></div></div><div>     <img src="container_runtime_files/2.JPG" type="image/jpeg" data-filename="2.JPG" width="498"/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">containerd概述：</span></div><ul><li><div>2016年12月14日，Docker公司宣布将containerd从Docker Engine中分离，并捐赠到一个</div></li></ul><div>     新的开源社区独立发展和运营，“<span style="font-weight: bold;">一个工业标准的容器运行时，注重简单、健壮性、可移植性</span>”。</div><ul><li><div>Docker 1.11的Docker Engine里就包含了containerd，而现在则是把containerd从Docker</div></li></ul><div>     Engine里彻底剥离出来，作为一个独立的开源项目独立发展，目标是提供一个更加开放、稳定</div><div>     的容器运行基础设施。</div><ul><li><div>需要独立的containerd的原因：</div></li></ul><div>     1. 继续从整体Docker Engine中分离（开源项目的思路）</div><div>     2. 可以被Kubernets CRI等项目使用（通用化）</div><div>     3. 为广泛的行业合作打下基础（像runC一样）</div><ul><li><div><span style="font-weight: bold;">Docker对容器的管理和操作基本都是通过containerd完成的。</span></div></li><li><div>containerd可以在宿主机中管理完整的容器生命周期：</div></li></ul><div>     1. 管理容器的生命周期：从创建容器到销毁容器</div><div>     2. 拉取、推送容器镜像</div><div>     3. 存储管理：管理镜像及容器数据的存储</div><div>     4. 调用runC运行容器</div><div>     5. 管理容器网络接口及网络：使用CNI容器网络接口</div><ul><li><div><span style="font-weight: bold;">containerd并不是直接面向开发人员或终端用户使用，而是主要用于集成到更上层的系统里</span>，</div></li></ul><div>     如Swarm、Kubernetes、Mesos等容器编排系统。</div><ul><li><div><span style="font-weight: bold;">containerd以守护进程的形式运行在系统上，通过</span> <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">unix domain socket</span> <span style="font-weight: bold;">暴露很低层的</span></div></li></ul><div><span style="font-weight: bold;">     </span><span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">gRPC API</span><span style="font-weight: bold;">，上层系统可以通过这些API管理机器上的容器。</span></div><ul><li><div>每个containerd只负责一台主机，拉取镜像，对容器的操作（启动、停止等），网络、存储</div></li></ul><div>     都是由containerd完成。</div><ul><li><div><span style="font-weight: bold;">具体运行容器由runC负责，实际上只要是符合OCI规范的容器都可以支持。</span></div></li><li><div>containerd架构示意：</div></li></ul><div>     <img src="container_runtime_files/containerd架构.png" type="image/png" data-filename="containerd架构.png" width="498"/></div><div><br/></div><ul><li><div>containerd的应用：</div></li></ul><div>     1. <span style="font-weight: bold;">docker镜像和containerd镜像通用，但组织方式和存放目录不同，导致docker与ctr命令</span></div><div><span style="font-weight: bold;">        不通用，各自管理自己的镜像和容器！</span></div><div>     2. containerd的默认配置文件：<span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">/etc/containerd/config.toml</span></div><div>        参考链接：<a href="https://github.com/containerd/containerd/blob/master/docs/ops.md">https://github.com/containerd/containerd/blob/master/docs/ops.md</a></div><div>     3. ctr命令行工具使用：</div><div>        $ sudo ctr images ls</div><div>        # 查看containerd镜像</div><div>        $ sudo ctr images pull docker.io/library/busybox:latest</div><div>        # 拉取containerd镜像</div><div>          <span style="color: rgb(0, 0, 255); font-weight: bold;">* 注意：</span>必须使用镜像的完整名称，否则报错！</div><div>        <span style="font-weight: bold;">$ sudo ctr run -t docker.io/library/nginx:latest mynginx</span></div><div>        # 运行containerd容器</div><div>        <span style="font-weight: bold;">$ sudo ctr plugins ls</span></div><div>        # 查看containerd支持的插件</div><div>        <img src="container_runtime_files/ctr命令行拉取容器镜像与运行容器.JPG" type="image/jpeg" data-filename="ctr命令行拉取容器镜像与运行容器.JPG" width="555"/></div><div>        <img src="container_runtime_files/ctr删除容器报错.JPG" type="image/jpeg" data-filename="ctr删除容器报错.JPG" width="557"/></div><div><br/></div><div>     4. containerd 1.2.x无法拉取containerd镜像的issue，升级containerd后可正常使用。</div><div>        <img src="container_runtime_files/Image.png" type="image/png" data-filename="Image.png" width="554"/></div><div>        参考链接：<a href="https://github.com/containerd/containerd/issues/1818">https://github.com/containerd/containerd/issues/1818</a></div><div>        </div><div><br/></div><div><span style="font-weight: bold;">容器运行时runtime分类：</span></div><ul><li><div>CNCF云原生计算基金会的Landscape中容器runtime项目：</div></li></ul><div>     <a href="https://github.com/cncf/landscape">https://github.com/cncf/landscape</a></div><div>     <img src="container_runtime_files/Image [1].png" type="image/png" data-filename="Image.png" width="311"/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Kubernetes中Docker容器runtime示例：</span></div><ul><li><div>以kubelet集成Docker容器runtime为例，解释kubelet如何创建容器。</div></li></ul><div>     <img src="container_runtime_files/1 [1].png" type="image/png" data-filename="1.png" width="496"/></div><div><span style="color: rgb(209, 0, 255); font-style: italic; font-weight: bold;">     * Step 1：</span></div><div>       1. kubelet通过 <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">CRI</span> <span style="font-weight: bold;">接口</span>（<span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">gRPC</span>）调用 dockershim，请求创建容器。</div><div>       2. CRI即容器运行时接口（container runtime interface），这一步中，kubelet</div><div>          可视作一个简单的CRI Client，而dockershim就是接收请求的Server。</div><div>       3. <span style="font-weight: bold;">目前 dockershim 的代码内嵌在 kubelet 中，所以接收调用的就是 kubelet 进程。</span></div><div>    </div><div>     <span style="color: rgb(209, 0, 255); font-style: italic; font-weight: bold;">* Step 2：</span></div><div>       dockershim收到请求后，转化成Docker Daemon可接收的请求，发送到Docker Daemon</div><div>       请求创建一个容器。</div><div><br/></div><div>     <span style="color: rgb(209, 0, 255); font-style: italic; font-weight: bold;">* Step 3：</span></div><div>       Docker Daemon早在1.11版本中就已经将针对容器的操作移到另一个守护进程，即</div><div>       containerd中，因此Docker Daemon仍然不能创建容器，而需请求 <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">containerd</span> 创建容器。</div><div><br/></div><div><span style="color: rgb(209, 0, 255); font-style: italic; font-weight: bold;">     * Step 4：</span></div><div>       1. containerd收到请求后，并不会直接去操作容器，而是创建 <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">containerd-shim</span> </div><div>          的进程，让containerd-shim去操作容器。</div><div>       2. <span style="font-weight: bold;">因为容器进程需要一个父进程来做诸如收集状态，维持STDIN等fd打开等工作。</span></div><div><br/></div><div><span style="color: rgb(209, 0, 255); font-style: italic; font-weight: bold;">     * Step 5：</span></div><div>       1. 创建容器需要设置 namespaces 和 cgroups，挂载 rootfs 等操作，而这些操作</div><div>          需通过 <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">OCI</span>（open container initiative，开放容器标准）。</div><div>       2. OCI的一个参考实现称为 <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">runC</span>。</div><div>       3. containerd-shim需要调用runc命令行启动容器。</div><div><br/></div><div>     <span style="color: rgb(209, 0, 255); font-style: italic; font-weight: bold;">* Step 6：</span></div><div>       1. <span style="font-weight: bold;">runc启动完容器后本身会直接退出，containerd-shim则会成为容器进程的</span><span style="font-weight: bold;">父进程，</span></div><div><span style="font-weight: bold;">          负责收集容器进程的状态，上报给containerd。</span></div><div>       2. 在容器中 PID 为 1 的进程退出后接管容器中的子进程进行清理，确保不会出现</div><div>          僵尸进程。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">容器发展史简要回顾：</span></div><ul><li><div>K8s最开始的runtime架构远没这么复杂，kubelet要创建容器直接调用Docker Daemon即可，</div></li></ul><div>     而那时也不存在containerd，Docker Daemon自己调用libcontainer库运行起来，整个过程</div><div>     即完成。</div><ul><li><div>然而，随着容器圈的一系列政治斗争，先是Google与Red Hat等认为运行时标准不能被Docker</div></li></ul><div>     一家公司控制，于是就创建了OCI开放容器标准。</div><ul><li><div>Docker则将 <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">libcontainer</span> 库封装成 runC，将其贡献作为OCI的参考实现。</div></li><li><div>接着 rkt 想从Docker那分一杯羹，希望K8s原生支持rkt作为运行时，而且PR还真将其合并。</div></li><li><div>但是，这样也造成在同时处理两种 runtime 的兼容性问题。</div></li><li><div>因此，负责维护kubelet的 sig-node 小组在 <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">Kubernetes 1.5</span> 推出 CRI 机制，即容器运行</div></li></ul><div>     时接口（container runtime interface），只要能实现该接口，即能成为runetime。</div><ul><li><div>不过CRI本身只是K8s推的标准，当时的K8s尚未达到如今的主导地位，容器运行时当然不能跟</div></li></ul><div>     K8s绑死只提供CRI接口，于是就有了 <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">shim</span><span style="font-weight: bold;">（垫片）</span>。</div><ul><li><div><span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">shim</span> <span style="font-weight: bold;">的职责就是作为接头将各种容器运行时本身的接口适配到 CRI 接口上。</span></div></li></ul><div><br/></div><ul><li><div>接下来Docker开发 Swarm 进军PaaS市场，将Docker做架构切分，把容器操作都转移到单独的</div></li></ul><div>    <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;"> </span><span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">containerd</span> 守护进程中，使Docker Daemon专门负责上层的封装编排。</div><ul><li><div><span style="font-weight: bold;">可惜Swarm惨败于K8s，之后Docker公司将 containerd 项目捐给CNCF。</span></div></li><li><div>最后Docker公司专注于开发Docker企业版。</div></li></ul><div><br/></div><ul><li><div>尽管已经有 CRI-O、containerd-plugin 这种更精简轻量的runtime，dockershim</div></li></ul><div>     作为经受最多生产环境考验的方案，迄今为止仍是K8s默认的runtime实现。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">OCI、runC与CRI概述：</span></div><ul><li><div><span style="font-weight: bold;">OCI</span>：开放容器标准，其实就是一系列文档，其中主要规定了两点。</div></li></ul><div>     1. 规定容器镜像，即 <span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">ImageSpec</span>。</div><div>        <span style="font-weight: bold;">主要定义一个 OCI image，该镜像由 manifest、image index（optional）、</span></div><div><span style="font-weight: bold;">        filesystem layers、以及 configuration 组成。</span></div><div>        该规范的目的在于确保能构建一套不同容器引擎间可互操作的工具，用于镜像的构建、</div><div>        传输，以及镜像运行准备工作。</div><div><br/></div><div>     2. 主要定义如何配置容器、执行环境以及容器生命周期中需要能接收哪些指令，这些</div><div>        指令的行为是什么，即 <span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">RuntimeSpec</span>。</div><div>        其中的大致内容为容器要能执行&quot;create&quot;、&quot;start&quot;、&quot;stop&quot;、&quot;delete&quot;这些命令，</div><div>        且行为要规范。</div><div><br/></div><ul><li><div><span style="font-weight: bold;">runC</span>：OCI的一种参考实现</div></li></ul><div>     1. <span style="font-weight: bold;">由libcontainer库演变而来，并且由Docker捐献给 Linux 基金会。</span></div><div>     2. libcontainer库直接使用Linux内核提供的相关隔离技术，如 namespace、cgroups。</div><div>     3. 它能按照标准将符合标准的容器镜像运行起来。</div><div><br/></div><ul><li><div>标准的好处就是方便搞创新，只要能符合标准，都能与生态圈中的其它工具一起工作。</div></li><li><div>那么镜像就可以用任意的工具去构建，容器就不一定非要用namespace和cgroups来隔离。</div></li><li><div>这就让各种虚拟化容器（<span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">Kata Container</span>）可以更好地参与到生态圈当中。</div></li></ul><div><br/></div><ul><li><div><span style="font-weight: bold;">CRI</span>：单纯是一组 gRPC 接口，可归纳为几套核心接口。</div></li></ul><div>     1. 针对容器操作的接口，包括创建、启停容器等。</div><div>     2. 针对镜像操作的接口，包括拉取镜像、删除镜像等。</div><div>     3. 针对 PodSandbox（容器沙箱环境）的操作接口。</div><div>        <span style="color: rgb(0, 0, 255); font-weight: bold;">* </span><span style="font-weight: bold;">Pod and container lifecycle management：</span></div><div>        <img src="container_runtime_files/Image [2].png" type="image/png" data-filename="Image.png" width="555"/></div><div><br/></div><div>        <span style="color: rgb(0, 0, 255); font-weight: bold;">* </span><span style="font-weight: bold;">Exec/attach/port-forward requests：</span></div><div>        <img src="container_runtime_files/Image [3].png" type="image/png" data-filename="Image.png" width="555"/></div><div><br/></div><div>     4. <span style="color: rgb(0, 0, 255); font-weight: bold;">CRI的工作原理：</span></div><div>        <span style="font-weight: bold;">CRI定义了一组关于Pod、Container与Image的gRPC接口，若cri-runtime与其对接，只需</span></div><div><span style="font-weight: bold;">        开发出一套相应的cri-runtime连接 shim 即可，就能被kubelet所调用。</span></div><div>        <img src="container_runtime_files/CRI工作原理.png" type="image/png" data-filename="CRI工作原理.png" width="475"/></div><div><br/></div><ul><li><div>因此，可以找到很多符合OCI标准或兼容了CRI接口的项目，而这些项目就大体构成了</div></li></ul><div>     整个Kuberentes的runtime生态：</div><div>     1. <span style="font-weight: bold;">OCI compatible</span>：</div><div>        runC、Kata（以及其前身runV和Clear Containers）、gVisor、railcar（Rust）</div><div>     2. <span style="font-weight: bold;">CRI compatible</span>：</div><div>        Docker（借助dockershim）、containerd、CRI-O、frakti</div><div><br/></div><ul><li><div>OCI和CRI的区别与联系，最容易让人产生混淆的一大原因就是社区里糟糕的命名。</div></li><li><div>以上的项目统统可以称为容器运行时（container runtime），彼此之间区分的办法就是给</div></li></ul><div>     “容器运行时” 这个词加上各种定语和从句来进行修饰。</div><ul><li><div>显然，container runtime就不是好名字，更准确的说法：<span style="font-weight: bold;">cri-runtime</span>、<span style="font-weight: bold;">oci-runtime</span></div></li><li><div>通过这个粗略的分类，其实可以总结出整个runtime架构不变的三层抽象：</div></li></ul><div>      <span style="font-weight: bold;">Orchestration API --</span><span style="font-family: &quot;DejaVu Sans Mono&quot;; font-weight: bold;">&gt;</span> <span style="font-weight: bold;">Container API --</span><span style="font-family: &quot;DejaVu Sans Mono&quot;; font-weight: bold;">&gt;</span> <span style="font-weight: bold;">Kernel API</span></div><ul><li><div>其中K8s已经是Orchestration API的事实标准，而Container API的接口标准就是</div></li></ul><div>     CRI，由cri-runtime实现，Kernel API的规范是OCI，由oci-runtime实现。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Kubernetes中containerd及CRI-O为容器runtime的架构演进：</span></div><ul><li><div>之前使用Docker的架构确实有点复杂，而复杂是万恶之源（其本质就是替代Docker）。</div></li><li><div>于是就促成直接使用 containerd 作为 oci-runtime 的方案。</div></li><li><div><span style="font-weight: bold;">当然，containerd还需要适配系统以对接CRI，该适配工作交由一个</span> <span style="color: rgb(0, 0, 255); font-style: italic; font-weight: bold;">shim</span><span style="font-weight: bold;"> 来完成。</span></div></li></ul><div><br/></div><ul><li><div>containerd 1.0中，对CRI的适配通过一个单独的进程 <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">CRI-containerd</span> 来完成。</div></li></ul><div>     <img src="container_runtime_files/2.png" type="image/png" data-filename="2.png" width="496"/></div><div>     <img src="container_runtime_files/容器运行时（3）.png" type="image/png" data-filename="容器运行时（3）.png" width="497"/></div><div><br/></div><ul><li><div>containerd 1.1中直接去除CRI-containerd进程，将适配逻辑作为插件放进containerd</div></li></ul><div>     主进程中，调用链如下所示：</div><div><span style="font-weight: bold;">     kubelet --</span><span style="font-family: &quot;DejaVu Sans Mono&quot;; font-weight: bold;">&gt;</span> <span style="font-weight: bold;">CRI-plugin（在containerd主进程中）--</span><span style="font-family: &quot;DejaVu Sans Mono&quot;; font-weight: bold;">&gt;</span> <span style="font-weight: bold;">containerd</span></div><div>     <img src="container_runtime_files/3.png" type="image/png" data-filename="3.png" width="497"/></div><div><br/></div><ul><li><div>但与此同时，社区就已经有了一个更为专注的cri-runtime，即 <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">CRI-O</span>。</div></li><li><div>它非常纯粹，兼容CRI和OCI，作为K8s与OpenShift专用的容器运行时。</div></li><li><div><span style="font-weight: bold;">其中</span> <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">conmon</span> <span style="font-weight: bold;">对应 containerd-shim，大体意图是一致的。</span></div></li></ul><div>     <img src="container_runtime_files/4 [1].png" type="image/png" data-filename="4.png" width="497"/></div><div><br/></div><ul><li><div><span style="font-weight: bold;">containerd与CRI-O架构总结：</span></div></li></ul><div>     <img src="container_runtime_files/容器运行时（1）.png" type="image/png" data-filename="容器运行时（1）.png" width="496"/></div><div>     <img src="container_runtime_files/容器运行时设计思想.png" type="image/png" data-filename="容器运行时设计思想.png" width="498"/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">CRI-O与Podman架构示意：</span></div><ul><li><div>CRI-O与kubelet集成方式：</div></li></ul><div>     <img src="container_runtime_files/kubelet集成CRI-O.png" type="image/png" data-filename="kubelet集成CRI-O.png" width="497"/></div><div>     <img src="container_runtime_files/CRI-O架构（2）.jpg" type="image/jpeg" data-filename="CRI-O架构（2）.jpg" width="497"/></div><div>     <img src="container_runtime_files/CRI-O官网架构.png" type="image/png" data-filename="CRI-O官网架构.png" width="497"/></div><div><br/></div><ul><li><div>Podman运行容器的方式：</div></li></ul><div>     1. <span style="font-weight: bold;">Podman曾经是CRI-O项目中的一部分，后来被分离出成为一个独立的项目，即</span> <span style="color: rgb(250, 122, 0); font-style: italic; font-weight: bold;">libpod</span><span style="font-weight: bold;">。</span></div><div>     2. Podman（Pod Manager）的目标是提供与 Docker 相似体验的container CLI，提供給</div><div>        使用者创建与运行容器。</div><div>        <img src="container_runtime_files/Podman原理.jpg" type="image/jpeg" data-filename="Podman原理.jpg" width="474"/>     </div><div><br/></div><div><span style="font-weight: bold;">参考链接：</span></div><ul><li><div>容器技术生态概览：</div></li></ul><div>     <a href="https://www.jianshu.com/p/453021b7c1ff?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">https://www.jianshu.com/p/453021b7c1ff?utm_campaign=</a></div><div>     <a href="https://www.jianshu.com/p/453021b7c1ff?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></div><ul><li><div>containerd简述：</div></li></ul><div>     <a href="https://www.cnblogs.com/embedded-linux/p/10850491.html">https://www.cnblogs.com/embedded-linux/p/10850491.html</a></div><ul><li><div><span style="font-weight: bold;">白话Kubernetes Runtime：</span></div></li></ul><div>     <a href="https://mp.weixin.qq.com/s/PpKz9FBIo_GCnxquh9F5ow">https://mp.weixin.qq.com/s/PpKz9FBIo_GCnxquh9F5ow</a>      </div><ul><li><div>容器运行时概述：</div></li></ul><div>     <a href="https://insujang.github.io/2019-10-31/container-runtime/">https://insujang.github.io/2019-10-31/container-runtime/</a></div><ul><li><div><span style="font-weight: bold;">Kubernetes官方手册中对CRI的说明：</span></div></li></ul><div>     <a href="https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/">https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/</a></div><ul><li><div><span style="font-weight: bold;">GitHub中对CRI的说明：</span></div></li></ul><div>     <a href="https://github.com/kubernetes/kubernetes/blob/242a97307b34076d5d8f5bbeb154fa4d97c9ef1d/docs/devel/container-runtime-interface.md">https://github.com/kubernetes/kubernetes/blob/</a></div><div>     <a href="https://github.com/kubernetes/kubernetes/blob/242a97307b34076d5d8f5bbeb154fa4d97c9ef1d/docs/devel/container-runtime-interface.md">242a97307b34076d5d8f5bbeb154fa4d97c9ef1d/docs/devel/container-runtime-interface.md</a></div><div>     </div></div><div><br/></div><div><br/></div></span>
</div></body></html> 